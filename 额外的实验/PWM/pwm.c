/*******************************************************************************  
* 文件名称：DS18B20温度传感器实验
* 实验目的：1.掌握单总线通讯基本特点和工作时序
*           2.掌握51单片机模拟单总线时序的程序设计方法
*           3.掌握DS18B20温度传感器的操作方法
* 实验配置：J3跳线配置为IO方式，J5配置为BTN、J2配置为1-3和2-4
* 程序现象：用手触摸温度传感器，数码管显示有变化
* 硬件说明：IAP15F2K61S2@11.0592MHz
* 注意事项：测量精度为1摄氏度
* 日期版本：2019-6-24/V2.0
*******************************************************************************/

#include "reg52.h"  //定义51单片机特殊功能寄存器
#include "absacc.h"

sfr AUXR = 0x8E;
sbit shu=P3^4;
 
code unsigned char tab[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff};
unsigned char dspbuf[8] = {10,10,10,10,10,10,10,10};//显示缓冲区

void display(void);

unsigned char show=0;
unsigned char wei=0;
unsigned char weishu=0;
unsigned char wei_flag=0;

void cls_led()
{
	P2 = ((P2&0x1f)|0x80); 
	P0 = 0xFF;
	P2 &= 0x1f;
}

void cls_buzz()
{
	P2 = ((P2&0x1f)|0xA0); 
	P0 = 0x00;
	P2 &= 0x1f;
}


void Timer0Init(void)		//1微秒@12.000MHz
{
	//AUXR &= 0x7F;		//定时器时钟12T模式
	TMOD = 0xF0;		//设置定时器模式
	TL0 = 0xFF;		//设置定时初值
	TH0 = 0xFF;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0 = 1;
}

void Timer1Init(void)		//1000微秒@12.000MHz
{
	//AUXR &= 0xBF;		//定时器时钟12T模式
	TMOD &= 0x0F;		//设置定时器模式
	TL1 = 0x18;		//设置定时初值
	TH1 = 0xFC;		//设置定时初值
	TF1 = 0;		//清除TF1标志
	TR1 = 1;		//定时器1开始计时
	ET1 = 1;
}

//主函数
void main(void)
{ 
		cls_buzz();
		cls_led();   
	  Timer0Init();
	  Timer1Init();
	  EA=1;
    while(1)
    {
			if(wei_flag==1)
			{
					wei_flag=0;
				  weishu=1<<wei;
				  if(++wei==8){wei=0;}
			}
    }
}

//定时器中断服务函数
void isr_timer_0(void)  interrupt 1  //默认中断优先级 1
{
    static unsigned int intr;
		intr++;
		if(intr <= 100)  //200us高电平
		{
				P0=weishu;
				P2 = ((P2&0x1f)|0x80); 
				P2 &= 0x1f;
    }
		if(intr>100&&intr<1000)
		{
				P0=0xff;
				P2 = ((P2&0x1f)|0x80); 
				P2 &= 0x1f;
		}
		if(intr==1000)
		{
			 intr=0;
		}
}

void isr_timer_1(void)  interrupt 3  //默认中断优先级 1
{
		static unsigned int a;
	  if(++a==1000)
		{
				a=0;
			  wei_flag=1;
		}
}

//显示函数
void display(void)
{   
	static unsigned char dspcom = 0;
	P2 = ((P2&0x1f)|0xE0);   //段选573
	P0 = 0xff;               //消隐段码
	P2 &= 0x1f; 

	P0 = 1<<dspcom;	         //循环位选
	P2 = ((P2&0x1f)|0xC0);   //位选573
	P2 &= 0x1f;
	
	P0 = tab[dspbuf[dspcom]];//显示段码
  P2 = ((P2&0x1f)|0xE0);   //段选573
	P2 &= 0x1f;               
	
    if(++dspcom == 8){
        dspcom = 0;
    }    
}
